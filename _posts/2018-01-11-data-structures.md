---
layout: page
title:  "Структуры данных в Python"
date:   2018-01-11 07:02:00 +1000
categories: python
draft: True
---

Как и в любом языке программирования в Python существует несколько типов
структур данных, это:

+ [Списки](#списки)
+ [Массивы](#массивы)
+ [Кортежи](#кортежи)
+ [Словари (ассоциативные массивы)](#словари)
+ [!!Важно!!](#важно)
+ [Множества](#множества)

### Списки

Это динамическая структура данных, которая может хранить объекты разнородных
типов с произвольным доступом к элементам (на самом деле он последовательный, но
мы можем получить доступ к любому элементу по его индексу). **Индексация
элементов списка начинается с нуля.** Из операций над списками, на начальном
этапе достаточно знать и уметь добавлять элементы в список и удалять их из него.

Создание объекта списка происходит так:

~~~ python
A=list() # пустой список
B=[] #пустой список
C=[12,13] # список из элементов [12, 13]
~~~

добавление и удаление элемента в/из списка происходит следующим образом:

~~~ python
A.append(1) # A=[1]
B=B+[1] #B=[1]
C.insert(1,2)# C=[12, 2, 13]
# удаление первого вхождения элемента в список
C.remove(13)# C=[12,2]
# доступ к элементу списка по  индексу
print(C[0]) # 12
# срез списка
print(C[0:1])# 12
# удаление элемента по его индексу
del C[0] #C=[2]
~~~

Надо сказать, что все операции так называемые _in place_, то есть в результате
ничего не возвращается и новый список не создается.

Чтобы добавить несколько элементов в список можно использовать оператор `+`, как
в строке 2 `B=B+[1,2,3,4,5]`{: .language-python}, тогда если изначальный список был `B=[0,5]`{: .language-python} , то
посте операции он станет `B=[0,5,1,2,3,4,5]`{: .language-python}. **Важно!!** если вы используете
`B.append([1,2,3,4,5])`{: .language-python}, то получите `B=[0,5,[1,2,3,4,5]]`{: .language-python}, то есть добавите
список как объект в список. Чтобы результат был идентичен, вместо _append_ нужно
использовать _extend_: `B.extend([1,2,3,4,5])`{: .language-python}.

Также список поддерживает методы очистки `clear()`{: .language-python} и сортировки `sort()`{: .language-python}.

~~~ py
A.append(1) # A=[1]
A=A+[1,2,5,6,3] #B=[1,1,2,5,6,3]
A.sort() #A=[1,1,2,3,5,6]
A.clear() #A=[]
~~~

Срез списка задается в формате **A[N:M]**, при этом элемент с номером *N*
включается в срез, а *M* - нет.

Для проверки наличия элемента в списке существует оператор `in`, пример:

~~~ py
A.append(1) # A=[1]
A=A+[1,2,5,6,3] #B=[1,1,2,5,6,3]
1 in A # True
10 in A # False
~~~

#### Пример <<список четных чисел>>

Создадим список, содержащий все четные числа от нуля до некоторого N

~~~ py
A=[]
N=10
for i in range(N):
    if i%2==0:
        A.append(i)
print(A)

>>[0, 2, 4, 6, 8]
~~~
 
### Массивы

Масивы в python подобны спискам, за исключением того, что хранят элементы одного и того же типа (basic type). Тип массив (array) реализован в пакете array, для его использования, сначала нужно его импортировать.

Конструктор массивов имеет формат:

`array.array(typecode,[initializer])`{: .language-python}

typecode - один из типов [Типы](https://docs.python.org/3/library/array.html#module-array)

На 64-битной машине размер элементов в байтах будет следующим

Type code|   C Type          |  Python type      | Minimum size in bytes
---------|-------------------|-------------------|----------------------
'b'      |signed char        |   int             |    1    
'B'      |unsigned char      |   int             |    1    
---------|-------------------|-------------------|----------------------
'u'      |Py_UNICODE         |Unicode character  |    2 
'h'      |signed short       |   int             |    2    
'H'      |unsigned short     |   int             |    2    
---------|-------------------|-------------------|----------------------
'i'      |signed int         |   int             |    4    
'I'      |unsigned int       |   int             |    4    
---------|-------------------|-------------------|----------------------
'l'      |signed long        |   int             |    8    
'L'      |unsigned long      |   int             |    8    
---------|-------------------|-------------------|----------------------
'q'      |signed long long   |   int             |    8
'Q'      |unsigned long long |   int             |    8
---------|-------------------|-------------------|----------------------
'f'      |float              |   float           |    4    
'd'      |double             |   float           |    8    

~~~ py
import array
a=array.array('i',[1,2,3,4]) # создаем массив двубайтовых целых чисел
a[1]=12
print(a)
>> array('i',[1,12,3,4])
~~~

Массивы поддерживают те же операции, что и списки

### Кортежи 

Кортежем или _tuple_ называется неизменяемый список. Создается он
следующим образом:

~~~ python
A=tuple() # пустой кортеж
B=()#пустой кортеж
C=(12,13) # кортеж из элементов (12, 13)
~~~

И соответственно кортеж не поддерживает операции добавления, сортировки,
вставки, удаления, расширения. Среди поддерживаемых операций - конкатенация

~~~ py
A=tuple() # пустой кортеж
A=A+(1,) #A=(1,)
~~~

Здесь стоит отметить, что в отличие от списка, где новый элемент просто
добавляется в конец,  происходит создание нового объекта.

~~~ py
A=list() # пустой список
B=A # список B и список A указывают на один и тот же объект
B==A # True
A=A+[1]
B==A # True Ничего не изменилось, ссылка на объект осталась прежней, A и B идентичны

A=tuple() # пустой кортеж
B=A # кортеж B и кортеж A указывают на один и тот же объект
B==A # True
A=A+(1,)
B==A # False Объект A - новый объект
~~~

Для кортежей доступ к элементу и выполнение срезов эквивалентно спискам,
отсутствует лишь возможность изменять кортеж.

Для проверки наличия элемента в кортеже все аналогично спискам.

### Словари 

*Словари или ассоциативные массивы* - это еще один способ
представления данных, отличие словаря от списка в том, что индексами могут быть
не только целые числа, но и любые объекты Python. В случае индексов - любые hashable объекты.

Создать ассоциативный массив просто:

~~~ py
A=dict() # пустой словарь
B={} # то же самое
С={"A":0.1, "B":0} # словарь с двумя элементами "A"=>0.1, "B"=>0
~~~

Чтобы поместить значение в ассоциативный массив, достаточно присвоить значение выбранному индексу, например `B[10]='Hello'`{: .language-python} или `B["12"]=12`{: .language-python}.

Из этих примеров видно, что индекс может быть действительно любым объектом, равно как и присваиваемое значение.

У словаря есть два важных метода: `keys()` и `values()`. Первый возвращает
список ключей, второй - список значений.

В случае словаря `B`, при вызове `B.keys()` мы получим `[10, "12"]`, а при вызове `B.values()` - `['Hello', 12]`

### Важно

При добавлении элементов в список, кортеж или словарь имейте ввиду, для atomic (immutable) и basic типов, создается ссылка на новый объект и помещается в словарь, для остальных объектов в словарь помещается ссылка на существующий объект. Если он в дальнейшем изменяется, то изменяется и содержимое словаря, кортежа, списка.

Пример:

~~~ py
import array

A=dict() # созадим словарь
B=[] # список
val=[1,2,3]
arr=array.array('d',[1,2,3])

A['1']=arr
A[2]=val
B.append(val)
B.append(arr)
В=(val, arr, )
print(A, '\n', B,'\n',D)

>> {'1': array('d', [1.0, 2.0, 3.0]), 2: [1, 2, 3]} 
>>  [[1, 2, 3], array('d', [1.0, 2.0, 3.0])]
>>  ([1, 2, 3], array('d', [1.0, 2.0, 3.0]),)

arr[0]=12
val.append('1')

print(A, '\n', B,'\n',D)

>>{'1': array('d', [12.0, 2.0, 3.0]), 2: [1, 2, 3, '1']} 
>> [[1, 2, 3, '1'], array('d', [12.0, 2.0, 3.0])]
>> ([1, 2, 3, '1'], array('d', [12.0, 2.0, 3.0]),)

~~~

Как видите, изменение ссылочного объекта вне словаря/списка/кортежа ведет к изменению его в словаре/списке/кортеже

### Множества

Это динамическая структура, содержащая уникальные значения.
Множество может содержать лишь _hashable_ объекты. Определяется так:

~~~ py
A=set()

~~~

Поддерживает все операции над множествами: включение, исключение, пересечение, объединение.

~~~ py
# пусть имеем два множества
a = {1,2,3}
b = {2,3,4}

# да-да, перечисление элементов в фигурных скобках означает инициализацию множества

a.difference(b)
>> {1}
b.difference(a)
>> {4}
a.union(b)
>> {1,2,3,4}
a.intersection(b)
>> {2,3}
a.issubset(b), a.issuperset(b)
>> False, False
a.symmetric_difference(b)
>> {1,4}
~~~

Множества чрезвычайно полезны, если нам нужно получить количество различающихся элементов или вычислить спектр значений дискретной переменной.

Или в задачах где заведомо требуется уникальность каждого элемента в списке.

С помощью множества (точнее преобразования списка во множество) можно удалить дубликаты из исходной последовательности:

~~~ py
a = [1,2,3,4,3,2,3,2,3,4]
b = set(a)
print(b)
>> {1,2,3,4}
~~~